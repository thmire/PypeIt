"""
Module for guiding Slit/Order tracing

.. _numpy.ndarray: https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html

"""
import os
import inspect
import copy
from IPython import embed

import numpy as np

from scipy import ndimage

from astropy.io import fits

from pypeit import msgs
from pypeit.core import parse, trace_slits, extract, pixels
#from pypeit.core import io
from pypeit import utils
from pypeit import masterframe
from pypeit import ginga
from pypeit.spectrographs import util

from pypeit.par import pypeitpar


class TraceSlits(masterframe.MasterFrame):
    """Class to guide slit/order tracing

    Args:
        spectrograph (:class:`pypeit.spectrographs.spectrograph.Spectrograph`):
            The `Spectrograph` instance that sets the instrument used to
            take the observations.  Used to set :attr:`spectrograph`.
        par (:class:`pypeit.par.pypeitpar.TraceSlitsPar` or None):
            The parameters used to guide slit tracing
        det (:obj:`int`, optional):
            The 1-indexed detector number to process.
        master_key (:obj:`str`, optional):
            The string identifier for the instrument configuration.  See
            :class:`pypeit.masterframe.MasterFrame`.
        master_dir (:obj:`str`, optional):
            Path to master frames.
        reuse_masters (:obj:`bool`, optional):
            Load master files from disk, if possible.
        msbpm (`numpy.ndarray`_, optional):
            Bad pixel mask.  If not provided, a dummy array with no
            masking is generated.
        qa_path (:obj:`str`, optional):
            Directory for QA output.

    Attributes:
        TODO: Come back to these...
        frametype (str): Hard-coded to 'trace'
        slit_left (ndarray [nrow, nslit]): Left edges, in physical space
        slit_righ (ndarray [nrow, nslit]): Right edges, in physical space
        slitpix (ndarray): Image specifying which pixels are in which slit
        slitcen : ndarray [nrow, nslit]
          Pixel values down the center of the slit
        extrapord : ndarray
          ??
        edgearr : ndarray
          Edge image
          -200000, 200000 indexing -- ??
          -100000, 100000 indexing -- Edges defined but additional work in progress
          -1, 1 indexing -- Edges finalized
        tc_dict : dict, optional
          Dict guiding multi-slit work
          [left,right][xval][edge]
        steps : list
          List of the processing steps performed
        siglev : ndarray
          Sobolev filtered image of mstrace
          Used to find images and used for tracing
        binarr : ndarray
          Uniform filter version of mstrace
          Generated by make_binarr()
        user_set : bool
          Did the user set the slit?  If so, most of the automated algorithms are skipped
        lmin : int
          Lowest left edge, edgearr value
        lmax : int
          Highest left edge, edgearr value
        rmin : int
          Lowest right edge, edgearr value
        rmax : int
          Highest right edge, edgearr value
        lcnt : int
          Number of left edges
        rcnt : int
          Number of right edges
    """
    # Frametype is a class attribute
#    frametype = 'trace'     # For ProcessImages base
    master_type = 'Trace'   # For MasterFrame base

    def __init__(self, spectrograph, par, binning=None, det=1, master_key=None, master_dir=None,
                 reuse_masters=False, qa_path=None, msbpm=None):

        # MasterFrame
        masterframe.MasterFrame.__init__(self, self.master_type, master_dir=master_dir,
                                         master_key=master_key, reuse_masters=reuse_masters)

        # Required parameters
        self.spectrograph = spectrograph
        self.par = par

        self.binning = None
        self.mstrace = None
        self.msbpm = msbpm

        # Optional parameters
        self.qa_path = qa_path
        self.det = det
        self.ednum = 100000

        # Main outputs
        self.slit_left = None           # narray
        self.slit_righ = None           # narray
        self.tc_dict = None             # dict
        self.edgearr = None             # ndarray
        self.siglev = None              # ndarray
        self.steps = []
        self.extrapord = None
        self.slitcen = None
        self.slitpix = None
        self.slit_left_tweak = None     # Tweaked slit boundaries from flat fielding routine.
        self.slit_righ_tweak = None

        # Key Internals
#        if mstrace is not None:
#            self.binarr = self._make_binarr()
        self.binarr = None
        self.user_set = None
        self.lmin = None
        self.lmax = None
        self.rmin = None
        self.rmax = None
        self.lcnt = None
        self.rcnt = None
        self.lcoeff = None
        # Fitting
        self.lnmbrarr = None
        self.ldiffarr = None
        self.lwghtarr = None
        self.rcoeff = None
        self.rnmbrarr = None
        self.rdiffarr = None
        self.rwghtarr = None

    @property
    def nslit(self):
        """
        Returns:
            int: Number of slits currently identified
        """
        return 0 if self.slit_left is None else self.slit_left.shape[1]

    def _edgearr_from_binarr(self):
        """
        Generate the first edgearr from the Sobolev produced siglev image
        Wrapper to trace_slits.edgearr_from_binarr

        :attr:`siglev` : ndarray (internal)
        :attr:`edgearr` : ndarray (internal)

        """
        self.siglev, self.edgearr \
                = trace_slits.edgearr_from_binarr(self.binarr, self.msbpm,
                                                   medrep=self.par['medrep'],
                                                   sobel_mode=self.par['sobel_mode'],
                                                   sigdetect=self.par['sigdetect'])
                                                   #number_slits=self.par['number'])
        # Step
        self.steps.append(inspect.stack()[0][3])

    def _add_left_right(self):
        """
        Add left/right edges to edgearr

        Wrapper to trace_slits.edgearr_add_left_right()
        If 0 is returned for both counts, this detector will be skipped

        Returns:
            bool: If True, at least one slit was added

        self.edgearr : ndarray (internal)
        self.lcnt : int (internal)
        self.rcnt : int (internal)


        """
        self.edgearr, self.lcnt, self.rcnt = trace_slits.edgearr_add_left_right(
            self.edgearr, self.binarr, self.msbpm, self.lcnt, self.rcnt, self.ednum)
        # Check on return
        if (self.lcnt == 0) and (self.rcnt == 0):
            any_slits = False
        else:
            any_slits = True

        # Step
        self.steps.append(inspect.stack()[0][3])
        return any_slits

    def add_user_slits(self, user_slits):
        """
        Add user-defined slit(s)

        Wrapper to trace_slits.add_user_edges()

        self.slit_left and self.slit_righ modified in place

        Args:
            user_slits (list):

        """
        # Reset (if needed) -- For running after PyepIt took a first pass
        #self.reset_edgearr_ednum()
        # Add user input slits
        self.slit_left, self.slit_righ \
                = trace_slits.add_user_edges(self.slit_left, self.slit_righ, user_slits)
        # Step
        self.steps.append(inspect.stack()[0][3])


    def _chk_for_longslit(self, fwhm=3.):
        """
        Are we done?, i.e. we have a simple longslit, i.e. one left and one right

        Args:
            fwhm (float, optional):

        Returns:
            bool:  True = longslit only

        """
        # TODO: Why is this here?
        orig = False
        if orig:
            if (self.lmax+1-self.lmin == 1) and (self.rmax+1-self.rmin == 1):
                plxbin = self.pixlocn[:, :, 0].copy()
                minvf, maxvf = plxbin[0, 0], plxbin[-1, 0]
                # Just a single order has been identified (i.e. probably longslit)
                msgs.info("Only one slit was identified. Should be a longslit.")
                xint = self.pixlocn[:, 0, 0]
                # Finish
                self.slit_left = np.zeros((self.mstrace.shape[0], 1))
                self.slit_righ = np.zeros((self.mstrace.shape[0], 1))
                self.slit_left[:, 0] = utils.func_val(self.lcoeff[:, 0], xint,
                                                      self.par['function'], minx=minvf, maxx=maxvf)
                self.slit_righ[:, 0] = utils.func_val(self.rcoeff[:, 0], xint,
                                                      self.par['function'], minx=minvf, maxx=maxvf)
                return True
            return False

        if len(self.tc_dict['left']['xval']) == 1 and len(self.tc_dict['right']['xval']) == 1:
            # fweight the trace crude
            for key,sign in zip(['left','right'], [1., -1.]):
                trace_crutch = self.tc_dict[key]['xset']
                trace_fweight = extract.iter_tracefit(np.fmax(sign*self.siglev, 0.0), trace_crutch,
                                                      self.par['trace_npoly'], fwhm=3.0*fwhm,
                                                      niter=9)[0]
                trace_gweight = extract.iter_tracefit(np.fmax(sign*self.siglev, 0.0),
                                                      trace_fweight, self.par['trace_npoly'],
                                                      fwhm=fwhm, gweight=True, niter=6)[0]
                self.tc_dict[key]['traces'] = trace_gweight
            return True
        return False


    def _fill_tslits_dict(self):
        """
        Build a simple dictionary holding the key trace bits and pieces that PypeIt wants

        Returns:
            dict: Trace slits dict

        """
        self.tslits_dict = {}

        # Have the slit boundaries been tweaked? If so use the tweaked
        # boundaries.  TODO: Have the dict keys have the same name as
        # the attribute
        self.tslits_dict['slit_left_orig'] = self.slit_left
        self.tslits_dict['slit_righ_orig'] = self.slit_righ

        if self.slit_left_tweak is not None:
            self.tslits_dict['slit_left_tweak'] = self.slit_left_tweak
            self.tslits_dict['slit_righ_tweak'] = self.slit_righ_tweak

            self.tslits_dict['slit_left'] = self.slit_left_tweak
            self.tslits_dict['slit_righ'] = self.slit_righ_tweak
        else:
            self.tslits_dict['slit_left'] = self.slit_left
            self.tslits_dict['slit_righ'] = self.slit_righ

        # Fill in the rest of the keys that were generated by
        # make_pixel_arrays from the slit boundaries. This was done with
        # tweaked boundaries if they exist.  TODO: Some of these
        # quantities may be deprecated.

        #for key in ['slitcen', 'pixwid', 'lordpix','rordpix', 'extrapord']:
        #    self.tslits_dict[key] = getattr(self, key)
        # add in the image size and some stuff to create the slitmask

        self.tslits_dict['maskslits'] = self.maskslits
        self.tslits_dict['slitcen'] = self.slitcen
        self.tslits_dict['nspec'] = self.mstrace.shape[0]
        self.tslits_dict['nspat'] = self.mstrace.shape[1]
        self.tslits_dict['nslits'] = self.slit_left.shape[1]
        self.tslits_dict['pad'] = self.par['pad']
        binspectral, binspatial = parse.parse_binning(self.binning)
        self.tslits_dict['binspectral'] = binspectral
        self.tslits_dict['binspatial'] = binspatial
        self.tslits_dict['spectrograph'] = self.spectrograph.spectrograph
        slit_spat_pos = trace_slits.slit_spat_pos(self.tslits_dict)
        spec_min_max = self.spectrograph.slit_minmax(slit_spat_pos, binspectral = binspectral)
        self.tslits_dict['spec_min'], self.tslits_dict['spec_max'] = spec_min_max[0, :], spec_min_max[1, :]
        # Now extrapolate the traces JFH turning this off for now.
        #self.tslits_dict['slit_left'] = trace_slits.extrapolate_trace(self.tslits_dict['slit_left'], spec_min_max)
        #self.tslits_dict['slit_righ'] = trace_slits.extrapolate_trace(self.tslits_dict['slit_righ'], spec_min_max)

        return self.tslits_dict

    def _final_left_right(self):
        """
        Last check on left/right edges

        Wrapper to trace_slits.edgearr_final_left_right()

        These are modified:
            self.edgearr : ndarray (internal)
            self.lcnt : int (internal)
            self.rcnt : int (internal)

        Returns:

        """
        # Final left/right edgearr fussing (as needed)
        self.edgearr, self.lcnt, self.rcnt = trace_slits.edgearr_final_left_right(
            self.edgearr, self.ednum, self.siglev)
        # Steps
        self.steps.append(inspect.stack()[0][3])

    def _make_pixel_arrays(self):
        """
        Generate pixel arrays
        Primarily for later stages of PypeIt

        Modified internally:
            self.slitcen
            self.slitpix

        Returns:

        """
        if self.slit_left_tweak is not None:
            msgs.info("Using tweaked slit boundaries determined from IllumFlat")
            slit_left = self.slit_left_tweak
            slit_righ = self.slit_righ_tweak
        else:
            slit_left = self.slit_left
            slit_righ = self.slit_righ
        # Convert physical traces into a pixel trace
        msgs.info("Converting physical trace locations to nearest pixel")

        # Notice that the slitcen is always defined relative to the
        # untweaked boundaries. This guarantees that the reference
        # location along the slit that we use for wavelength calibration
        # and for tilts is always at a fixed unchanging location.
        self.slitcen = 0.5*(self.slit_left+self.slit_righ)
        #self.pixwid = (slit_righ-slit_left).mean(0).astype(np.int)

    def _make_binarr(self):
        """
        Lightly process mstrace

        Returns:
            ndarray: The processed image

        """
        #  Only filter in the spectral dimension, not spatial!
        self.binarr = ndimage.uniform_filter(self.mstrace, size=(3, 1), mode='mirror')
        # Step
        self.steps.append(inspect.stack()[0][3])
        return self.binarr


    def _match_edges(self):
        """
        # Assign a number to each edge 'grouping'

        Wrapper to trace_slits.match_edges()

        Modified internally:
            self.edgearr  : ndarray (internal)
            self.lcnt : int (intenal)
            self.rcnt: int (intenal)

        Returns:

        """

        self.lcnt, self.rcnt = trace_slits.match_edges(self.edgearr, self.ednum)
        # Sanity check (unlikely we will ever hit this)
        if self.lcnt >= self.ednum or self.rcnt >= self.ednum:
            msgs.error("Found more edges than allowed by ednum. Set ednum to a larger number.")
        # Step
        self.steps.append(inspect.stack()[0][3])

    def _maxgap_prep(self):
        """
        First step in the maxgap algorithm
          Likely to be Deprecated

        Returns
        -------
        self.edgearr  : ndarray (internal)
        self.edgearrcp  : ndarray (internal)

        """
        self.edgearrcp = self.edgearr.copy()
        self.edgearr[np.where(self.edgearr < 0)] += 1 + np.max(self.edgearr) - np.min(self.edgearr)
        # Step
        self.steps.append(inspect.stack()[0][3])


    def _mslit_sync(self):
        """
        Synchronize slits

        Wrapper to trace_slits.sync_edges()

        Returns:

        """
        #
        trace_slits.sync_edges(self.tc_dict, self.mstrace.shape[1])

        # Step
        self.steps.append(inspect.stack()[0][3])

    def _mslit_tcrude(self, maxshift=0.15):
        """
        Trace crude me
          And fuss with slits

        Wrapper to trace_slits.edgearr_tcrude()

        self.edgearr  : ndarray (internal)
        self.tc_dict  : dict (internal)

        Args:
            maxshift (float, optional):  Maximum shift allowed as the trace curves

        Returns:

        """
        # Settings
        _maxshift = self.par['maxshift'] if 'maxshift' in self.par.keys() else maxshift

        # TODO: JFH The edgearr looks like we could just pydl fit it and
        # then trace with a crutch as the first step rather than using
        # trace_crude
        self.edgearr, self.tc_dict = trace_slits.edgearr_tcrude(self.edgearr, self.siglev,
                                                                self.ednum, maxshift=_maxshift,
                                                                bpm=self.msbpm)
        # Step
        self.steps.append(inspect.stack()[0][3])

    # TODO: JFH The PCA coefficients take on a wide range of values
    # which makes mad rejection less meaingful. I wonder if we should be
    # doing rejection and fitting using relative errors and relative
    # error deviations.
    def _pca_refine(self, mask_frac_thresh=0.6, coeff_npoly_pca=2, show=False, debug=False):
        """
        Mainly a driver routine to trace_slits.trace_refine() method

        Takes the trace_crude outputs from mslit_tcrude and performs
        a PCA analysis to predict curvature across the detector.

        Slit edges are then found in a rectified, smashed image

        Behavior is distinct for multi-slit vs. echelle

        Fills tc_dict with the 'traces' arrays (in left, right)

        Args:
            mask_frac_thresh (float, optional: Fraction of the slit traced by crude which
                must be 'good' to be included in the first analysis
            coeff_npoly_pca (int, optional):  Number of PCA coefficients to consider
            show: bool, optional

        Returns:

        """
        nspec, nspat = self.siglev.shape

        # Fuss with parameters here
        if self.spectrograph.pypeline == 'MultiSlit':
            maxiter = 2
        else:
            maxiter = 3

        # Unpack and sort
        # Left
        slit_left_mean = np.mean(self.tc_dict['left']['xset'],0)
        isort_left = slit_left_mean.argsort()
        slit_left = self.tc_dict['left']['xset'][:, isort_left]
        slit_left_err = self.tc_dict['left']['xerr'][:, isort_left]
        # Right
        slit_righ_mean = np.mean(self.tc_dict['right']['xset'],0)
        isort_righ = slit_righ_mean.argsort()
        slit_righ = self.tc_dict['right']['xset'][:, isort_righ]
        slit_righ_err = self.tc_dict['right']['xerr'][:, isort_righ]

        # Cut on edges
        # Left
        mask_left = (slit_left_err < 900)
        mask_frac_left = np.sum(mask_left, 0) / nspec
        keep_left = mask_frac_left > mask_frac_thresh
        slit_left = slit_left[:, keep_left]
        mask_left = mask_left[:, keep_left]
        # Right
        mask_righ = (slit_righ_err < 900)
        mask_frac_righ = np.sum(mask_righ, 0) / nspec
        keep_righ = mask_frac_righ > mask_frac_thresh
        slit_righ = slit_righ[:, keep_righ]
        mask_righ = mask_righ[:, keep_righ]

        # Do we have enough?
        if np.sum(keep_righ) + np.sum(keep_left) < 5:
            msgs.warn("Less than 5 edges available for the PCA.  Consider lower mask_frac_thresh")

        # Echelle or multi-slit?
        if self.spectrograph.pypeline == 'MultiSlit':
            # Combine left and right slit edges
            slit_in = np.append(slit_left, slit_righ, axis=1)
            mask_in = np.append(mask_left, mask_righ, axis=1)
            # Run it!
            iter = 1
            while iter <= maxiter:
                msgs.info('Doing trace_refine iter#{:d}'.format(iter))
                edges_dict = trace_slits.trace_refine(
                    self.siglev, slit_in, mask_in, npca=None, ncoeff=self.par['trace_npoly'],
                    pca_explained_var=99.8, coeff_npoly_pca=coeff_npoly_pca, fwhm=3.0,
                    sigthresh=self.par['sigdetect'], smash_range=self.par['smash_range'],
                    trc_thresh = -np.inf, debug=debug)
                # Prep for round 2+
                slit_in = np.append(edges_dict['left']['trace'],
                                    edges_dict['right']['trace'], axis=1)
                mask_in = np.ones_like(slit_in, dtype=bool)
                iter += 1
                # Show
                if show:
                    edges_dict['show'] = 'both'
                    self.show('refined_edges', extras=edges_dict)
        else:
            # Run on left edges
            slit_in = slit_left.copy()
            mask_in = mask_left.copy()
            iter = 1
            while iter <= maxiter:
                msgs.info('Doing trace_refine iter#{:d}'.format(iter))
                trace_dict_l = trace_slits.trace_refine(self.siglev, slit_in, mask_in, npca=None,
                                                        ncoeff=self.par['trace_npoly'],
                                                        pca_explained_var=99.8,
                                                        coeff_npoly_pca=coeff_npoly_pca, fwhm=3.0,
                                                        sigthresh=self.par['sigdetect'],
                                                        smash_range=self.par['smash_range'],
                                                        trc_thresh=10.0, debug=debug, maxrej=1)
                slit_in = trace_dict_l['left']['trace']
                mask_in = np.ones_like(slit_in, dtype=bool)
                iter += 1

                if show:
                    trace_dict_l['show'] = 'left'
                    self.show('refined_edges', extras=trace_dict_l)

            # TODO -- Should sync up left-right in one big while loop after doing one iteration
            # Run on right edges
            iter = 1
            slit_in = slit_righ.copy()
            mask_in = mask_righ.copy()
            while iter <= maxiter:
                msgs.info('Doing trace_refine iter#{:d}'.format(iter))
                trace_dict_r = trace_slits.trace_refine(self.siglev, slit_in, mask_in, npca=None,
                                                        ncoeff=self.par['trace_npoly'],
                                                        pca_explained_var=99.8,
                                                        coeff_npoly_pca=coeff_npoly_pca, fwhm=3.0,
                                                        sigthresh=self.par['sigdetect'],
                                                        trc_thresh=10.0, debug=debug, maxrej=1)
                slit_in = trace_dict_r['right']['trace']
                mask_in = np.ones_like(slit_in, dtype=bool)
                iter += 1

                if show:
                    trace_dict_r['show'] = 'right'
                    self.show('refined_edges', extras=trace_dict_r)
            # Merge left and right
            edges_dict = {}
            edges_dict['left'] = trace_dict_l['left'].copy()
            edges_dict['right'] = trace_dict_r['right'].copy()

            # A final show
            if show:
                edges_dict['show'] = 'both'
                self.show('refined_edges', extras=edges_dict)

        # Update tc_dict -- we now leave edgearr behind!
        ypos = nspec // 2
        for side in ['left', 'right']:
            xvals = edges_dict[side]['trace'][ypos,:]
            self.tc_dict[side]['xval'] = xvals
            self.tc_dict[side]['traces'] = edges_dict[side]['trace'].copy()
        # Step
        self.steps.append(inspect.stack()[0][3])

    def rm_user_slits(self, user_slits):
        """
        Remove one or more slits (as applicable)

        Wrapper to trace_slits.rm_user_edges()

        self.slit_left, self.slit_righ modified in-place

        Args:
            user_slits (list):  List of user slits to remove

        """
        # Remove user input slits
        self.slit_left, self.slit_righ \
                = trace_slits.rm_user_edges(self.slit_left, self.slit_righ, user_slits)
        # Step
        self.steps.append(inspect.stack()[0][3])

    def _trim_slits(self, trim_slits=True, plate_scale = None, ech_slit_tol = 0.3):
        """
        Trim slits
          Mainly those that fell off the detector
          Or have width less than fracignore

        Modified internally
            self.slit_left  : ndarray (internal)
            self.slit_righ  : ndarray (internal)

        Args:
            trim_slits: bool, optional
            plate_scale: float, optional
            ech_slit_tol: float, optional

        Returns:

        """

        # TODO: JFH In principle we could make this trim_slits function
        # a method in the generic spectrograph function, which could
        # then be overloaded by the echelle spectrographs
        nslit = self.slit_left.shape[1]
        nspat = self.mstrace.shape[1]
        mask = np.ones(nslit,dtype=bool)

        min_val = np.min(self.slit_left,axis=0)
        max_val = np.max(self.slit_righ,axis=0)

        off_detector = (min_val > nspat) | (max_val < 0)
        mask[off_detector] = False
        # Print out a status message
        ioff = np.where(off_detector)[0]
        for islit in ioff:
            msgs.info('Slit {0:d} is off the detector - ignoring this slit'.format(islit))

        if trim_slits:
            slit_width = np.median((self.slit_righ - self.slit_left) * plate_scale, axis=0)

            if self.spectrograph.pypeline == 'MultiSlit':
                too_short = slit_width < self.par['min_slit_width']
                ishort = np.where(too_short)[0]
                mask[ishort] = False
                for islit in ishort:
                    msgs.info('Slit {0:d}'.format(islit)
                              + ' has width = {:6.3f}'.format(slit_width[islit])
                              + ' arcseconds < less than min_slit_width = {:} arcseconds'.format(
                                    self.par['min_slit_width']) + ' - ignoring this slit')

            elif self.spectrograph.pypeline == 'Echelle':
                # TODO: JFH Once we have orders that shrink because of
                # overlap ech_slit_tol will need to be adjusted
                med_width = np.median(slit_width[mask])
                wrong_size = (slit_width > (1.0 + ech_slit_tol)*med_width) \
                                | (slit_width < (1.0 - ech_slit_tol)*med_width)
                iwrong = np.where(wrong_size)[0]
                mask[iwrong] = False
                for islit in iwrong:
                    msgs.info('Order {0:d}'.format(islit) + ' has width = {:6.3f}'.format(
                                    slit_width[islit])
                               + ' arcseconds, which is not within ech_slit_tol = {:}%'.format(
                                    100.0*ech_slit_tol)
                               + ' of the median order width of {:5.3f}'.format(med_width)
                               + ' arcseconds - ignoring this order')
        # Trim
        self.slit_left = self.slit_left[:, mask]
        self.slit_righ = self.slit_righ[:, mask]
        # Step
        self.steps.append(inspect.stack()[0][3])

    def show(self, attr='edges', pstep=50, extras=None):
        """
        Display an image or spectrum in TraceSlits

        Args:
            attr (str, optional):
              'edges' -- Show the mstrace image and the edges
              'binarr' -- Show the binarr image
              'edgearr' -- Show the edgearr image
              'siglev' -- Show the Sobolev image
              'traces' -- Show the traces at an intermediate stage
              'refined_edges' -- Show the traces at an intermediate stage in _pca_refine()
              'xset' -- Check the output from the trace crude
            extras: anything
              Extra bits and pieces needed for plotting
        """
        if attr == 'edges':
            viewer, ch = ginga.show_image(self.mstrace, chname='edges')
            if self.slit_left is not None:
                ginga.show_slits(viewer, ch, self.slit_left, self.slit_righ,
                        slit_ids=(np.arange(self.slit_left.shape[1]).astype(int) + 1).tolist(),
                        pstep=pstep)
        elif attr == 'binarr':
            ginga.show_image(self.binarr, chname='binarr')
        elif attr == 'xset':
            viewer, ch = ginga.show_image(self.mstrace, chname='slit_xset')
            color = dict(left='green', right='red')
            viewer, ch = ginga.show_image(self.mstrace)
            for side in ['left', 'right']:
                for kk in range(self.tc_dict[side]['xset'].shape[1]):
                    ginga.show_trace(viewer, ch, self.tc_dict[side]['xset'][:, kk],
                                     trc_name=side+ str(kk),color=color[side])
        elif attr == 'refined_edges':
            # Used in _pca_refine()
            edges_dict = extras
            #
            color = dict(left='green', right='red')
            viewer, ch = ginga.show_image(self.mstrace, chname='refined_edges')
            if edges_dict['show'] == 'both':
                for side in ['left', 'right']:
                    for kk in range(edges_dict[side]['nstart']):
                        ginga.show_trace(viewer, ch, edges_dict[side]['trace'][:, kk],
                                         trc_name=side + str(kk), color=color[side])
            else:
                for side in [edges_dict['show']]:
                    for kk in range(edges_dict[side]['nstart']):
                        ginga.show_trace(viewer, ch, edges_dict[side]['trace'][:, kk],
                                         trc_name='left_' + str(kk), color=color[side])
        elif attr == 'traces':
            viewer, ch = ginga.show_image(self.mstrace, chname='slit_traces')
            color = dict(left='green', right='red')
            viewer, ch = ginga.show_image(self.mstrace)
            for side in ['left', 'right']:
                for kk in range(self.tc_dict[side]['traces'].shape[1]):
                    ginga.show_trace(viewer, ch, self.tc_dict[side]['traces'][:, kk],
                                     trc_name=side+ str(kk),color=color[side], pstep=pstep)
        elif attr == 'edgearr':
            if np.min(self.edgearr) == -1: # Ungrouped
                tmp = self.mstrace.copy()
                # Left edges
                left = self.edgearr == -1
                tmp[left] = -99999.
                # Right edges
                right = self.edgearr == 1
                tmp[right] = 99999.
                viewer, ch = ginga.show_image(tmp, chname='edgearr')
            else: # Grouped
                viewer, ch = ginga.show_image(self.siglev, chname='edgearr')
                # Traces
                all_uni = np.unique(self.edgearr[self.edgearr != 0])
                for uni in all_uni:
                    # Color
                    clr = 'green' if uni < 0 else 'red'
                    # Do it
                    tidx = np.where(self.edgearr == uni)
                    ginga.show_trace(viewer, ch, tidx[1], trc_name=str(uni), yval=tidx[0],
                                     color=clr)
        elif attr == 'siglev':
            ginga.show_image(self.siglev, chname='siglev')

    def run(self, mstrace, binning, add_user_slits=None, rm_user_slits=None, trim_slits=True,
            plate_scale=None, show=False, write_qa=True, debug=False, msbpm=None):
        """
        Main driver for tracing slits.

          Code flow
           1.  Determine approximate slit edges (left, right)
             1b.    Trim down to one pixel per edge per row [seems wasteful, but ok]
           2.  Give edges ID numbers + stitch together partial edges (match_edges)
             2b.   first maxgap option -- NOT recommended
           3.  Assign slits (left, right) ::  Deep algorithm
           4.  For ARMLSD
              -- Trace crude the edges
              -- Do a multi-slit sync to pair up left/right edges
           5.  Remove short slits -- Not recommended for ARMLSD
           6.  Fit left/right slits
           7.  Synchronize
           8.  Extrapolate into blank regions (PCA)
           9.  Perform pixel-level calculations
           10. Make the QA plot

        Args:
            mstrace (`numpy.ndarray`_):
                Trace image
            binning (:obj:`str`, optional):
                A comma-separated string with the pixel binning in each
                dimension.  Order *must* follow the PypeIt convention of
                spectral then spatial binning to match the orientation
                of images in PypeIt; see [this doc].  If None, assumed
                to be '1,1'.
            ignore_orders : bool (optional)
              Perform ignore_orders algorithm (recommended only for echelle data)
            add_user_slits : list of lists
              List of 3 element lists, each an [xleft, xright, yrow] specifying a slit edge
              at a given yrow
            rm_user_slits : list of lists
              List of 2 element lists, each an [xcen, yrow] specifying a slit center.  Any
              slit containing it will be removed

        Returns:
            dict or None (if no slits): Primary keys are --
              'slit_left'
              'slit_righ'
              'slitcen'
              'extrapord'
              'slitpix'
        """
        # Point to input data
        self.mstrace = mstrace
        self.binning = binning

        # Ensure the bad-pixel mask is available
        if self.msbpm is None and msbpm is None:
            # No bad-pixel mask available, so just assume all pixels are
            # good
            self.msbpm = np.zeros_like(self.mstrace)
        if msbpm is not None:
            # Overwrite any existing bad-pixel mask if a new one is
            # provided
            self.msbpm = msbpm

        # Check shapes
        if self.mstrace.shape != self.msbpm.shape:
            msgs.error('Trace and bad-pixel mask images are not the same size!')

        # Generate binarr
        _ = self._make_binarr()

        # Specify a single slit?
        if len(self.par['single']) > 0:  # Single slit
            self._edgearr_single_slit()
            self.user_set = True
        else:  # Generate the edgearr from the input trace image
            self._edgearr_from_binarr()
            self.user_set = False

        # Assign a number to each edge 'grouping'
        self._match_edges()

        # Add in a *single* left/right edge?
        #  Mainly useful for longslit where one or both sides butt up on the edge of the detector
        any_slits = self._add_left_right()
        if not any_slits:
            return None

        # Final left/right edgearr fussing (as needed)
        #  Mainly useful for longslit
        if not self.user_set:
            self._final_left_right()

        # Trace crude in siglev image and sync traces
        self._mslit_tcrude()

        # Are we done, e.g. a simple longslit?
        #   Check if no further work is needed (i.e. there only exists one order)
        if self._chk_for_longslit():
            pass
        else:  # No, not done yet
            # Refine
            self._pca_refine(mask_frac_thresh=self.par['mask_frac_thresh'], debug=debug, show=show)
            # Synchronize and add in edges
            self._mslit_sync()

        # Set slit_left and slit_righ, lmin, lmax
        self.slit_left = self.tc_dict['left']['traces']
        self.slit_righ = self.tc_dict['right']['traces']
        self.lmin, self.lmax = 0, self.slit_left.shape[1]
        self.rmin, self.rmax = 0, self.slit_righ.shape[1]
        self.extrapord = np.zeros(self.slit_left.shape[1], dtype=np.bool)

        # Remove any slits that are completely off the detector
        #   Also remove short slits here for multi-slit and long-slit (alignment stars)
        #if self.nslit > 1:
        self._trim_slits(trim_slits=trim_slits, plate_scale=plate_scale)

        # Adjust slit edges
        self.slit_left += self.par['trim'][0]
        self.slit_righ -= self.par['trim'][1]
        # Extrapolate traces

        # These need to be done last!
        # Add user input slits
        if add_user_slits is not None:
            self.add_user_slits(add_user_slits)
        # Remove user input slits
        if rm_user_slits is not None:
            self.rm_user_slits(rm_user_slits)

        # Generate pixel arrays
        self._make_pixel_arrays()

        # Mask
        self.maskslits = np.zeros(self.slit_left.shape[1], dtype=np.bool)

        # fill dict for PypeIt
        self.tslits_dict = self._fill_tslits_dict()

        # Make the QA
        if write_qa:
            self._qa()


        # Return it
        return self.tslits_dict

    def _qa(self, use_slitid=True):
        """
        QA
          Wrapper to trace_slits.slit_trace_qa()

        Returns
        -------

        """
        slitmask = pixels.tslits2mask(self.tslits_dict)
        trace_slits.slit_trace_qa(self.mstrace, self.slit_left,
                                   self.slit_righ, slitmask, self.extrapord, self.master_key,
                                   desc="Trace of the slit edges D{:02d}".format(self.det),
                                   use_slitid=use_slitid, out_dir=self.qa_path)


    def __repr__(self):
        # Generate sets string
        txt = '<{:s}: '.format(self.__class__.__name__)
        if len(self.steps) > 0:
            txt+= ' steps: ['
            for step in self.steps:
                txt += '{:s}, '.format(step)
            txt = txt[:-2]+']'  # Trim the trailing comma
        txt += '>'
        return txt

    # TODO: Allowing traceImage to be passed, allowing it to be either
    # a TraceImage or a numpy.ndarray, and allowing tslits_dict to be
    # passed are all kludges.
    def save(self, outfile=None, overwrite=True, traceImage=None, tslits_dict=None):
        """
        Save the main TraceSlits data as a MasterFrame.

        TODO: Change the format of this...

        Args:
            outfile (:obj:`str`, optional):
                Name for the output file.  Defaults to
                :attr:`master_file_path`.
            overwrite (:obj:`bool`, optional):
                Overwrite any existing file.
            traceImage (`numpy.ndarray`_, :class:`pypeit.traceimage.TraceImage`, optional):
                An array with only the image data or the full
                :class:`pypeit.traceimage.TraceImage` instance with the
                data used to construct the slit traces.
        """
        _outfile = self.master_file_path if outfile is None else outfile
        # Check if it exists
        if os.path.exists(_outfile) and not overwrite:
            msgs.warn('Master file exists: {0}'.format(_outfile) + msgs.newline()
                      + 'Set overwrite=True to overwrite it.')
            return

        _tslits_dict = self.tslits_dict if tslits_dict is None else tslits_dict

        # Log
        msgs.info('Saving master frame to {0}'.format(_outfile))

        # Build the header
        hdr = self.build_master_header(steps=self.steps)#, raw_files=self.file_list)

        #   - Slit metadata
        hdr['FRAMETYP'] = (self.master_type, 'PypeIt: Master calibration frame type')
        # TODO: Provide header comments
        hdr['DET'] = self.det
        hdr['NSPEC'] = _tslits_dict['nspec']
        hdr['NSPAT'] =  _tslits_dict['nspat']
        hdr['NSLITS'] =  _tslits_dict['nslits']
        hdr['PAD'] = _tslits_dict['pad']
        hdr['BINSPEC'] = _tslits_dict['binspectral']
        hdr['BINSPAT'] = _tslits_dict['binspatial']
        hdr['SPECTROG'] = _tslits_dict['spectrograph']

        # Collect data that may be None.  If they are None, no data will
        # be in the relevant extensions.
        mstrace = self.mstrace
        if traceImage is not None:
            try:
                mstrace = traceImage.image
            except:
                # Assume it failed because it's not a TraceImage object
                # and it's a numpy.ndarray to write.
                mstrace = traceImage
        left_orig = None if 'slit_left_orig' not in _tslits_dict.keys() \
                        else _tslits_dict['slit_left_orig']
        righ_orig = None if 'slit_righ_orig' not in _tslits_dict.keys() \
                        else _tslits_dict['slit_righ_orig']

        # Write the file
        fits.HDUList([fits.PrimaryHDU(header=hdr),
                      fits.ImageHDU(data=mstrace, name='TRACEIMG'),
                      # TODO: These should be written to a BinaryTable
                      fits.ImageHDU(data=_tslits_dict['slit_left'], name='SLIT_LEFT'),
                      fits.ImageHDU(data=_tslits_dict['slit_righ'], name='SLIT_RIGH'),
                      fits.ImageHDU(data=_tslits_dict['slitcen'], name='SLITCEN'),
                      fits.ImageHDU(data=_tslits_dict['spec_min'], name='SPEC_MIN'),
                      fits.ImageHDU(data=_tslits_dict['spec_max'], name='SPEC_MAX'),
                      fits.ImageHDU(data=left_orig, name='SLIT_LEFT_ORIG'),
                      fits.ImageHDU(data=righ_orig, name='SLIT_RIGH_ORIG'),
                      fits.ImageHDU(data=_tslits_dict['maskslits'].astype(int), name='MASK'),  # int deals with bool
                     ]).writeto(_outfile, overwrite=True)

    def load(self, ifile=None, return_header=False):
        """
        Load the trace slits data.

        Reads both the trace data and the trace image data.  This is
        largely a wrapper for
        :func:`pypeit.traceslits.TraceSlits.load_from_file`.

        Args:
            ifile (:obj:`str`, optional):
                Name of the master frame file.  Defaults to
                :attr:`master_file_path`.
            return_header (:obj:`bool`, optional):
                Return the header, which will include the TraceImage
                metadata if available.

        Returns:
            tuple: Returns the trace slits dictionary and the trace slit
            image.  If return_header is true, the primary header is also
            returned.  If nothing is loaded, either because
            :attr:`reuse_masters` is `False` or the file does not exist,
            everything is returned as None (one per expected return
            object).
        """
        # Format the input and set the tuple for an empty return
        _ifile = self.master_file_path if ifile is None else ifile
        empty_return = (None, None, None) if return_header else (None, None)

        if not self.reuse_masters:
            # User does not want to load masters
            msgs.warn('PypeIt will not reuse masters!')
            return empty_return

        if not os.path.isfile(_ifile):
            # Master file doesn't exist
            msgs.warn('No Master {0} frame found: {1}'.format(self.master_type, self.master_file_path))
            return empty_return

        # Read and return
        msgs.info('Loading Master {0} frame: {1}'.format(self.master_type, _ifile))
        return self.load_from_file(_ifile, return_header=return_header)

    # TODO: Allows for a read one-liner...
    @staticmethod
    def load_from_file(filename, return_header=False):
        """
        Load the trace slits data, without the benefit of the rest of
        the class.

        Reads both the trace data and the trace image data.

        Args:
            filename (:obj:`str`):
                Name of the master frame file.
            return_header (:obj:`bool`, optional):
                Return the header, which will include the TraceImage
                metadata if available.

        Returns:
            tuple: Returns the trace slits dictionary and the trace slit
            image.  If return_header is true, the primary header is also
            returned.  If nothing is loaded, either because
            :attr:`reuse_masters` is `False` or the file does not exist,
            everything is returned as None (one per expected return
            object).
        """
        if not os.path.isfile(filename):
            msgs.error('File does not exist: {0}'.format(filename))

        hdu = fits.open(filename)

        # Trace image
        mstrace = hdu['TRACEIMG'].data

        # Trace dictionary
        tslits_dict={}
        #   - Meta data
        tslits_dict['nspec'] = hdu[0].header['NSPEC']
        tslits_dict['nspat'] = hdu[0].header['NSPAT']
        tslits_dict['nslits'] = hdu[0].header['NSLITS']
        tslits_dict['pad'] = hdu[0].header['PAD']
        tslits_dict['binspectral'] = hdu[0].header['BINSPEC']
        tslits_dict['binspatial'] = hdu[0].header['BINSPAT']
        tslits_dict['spectrograph'] = hdu[0].header['SPECTROG']
        #   - "Image" data
        tslits_dict['slit_left'] = hdu['SLIT_LEFT'].data
        tslits_dict['slit_righ'] = hdu['SLIT_RIGH'].data
        tslits_dict['slitcen']   = hdu['SLITCEN'].data
        tslits_dict['spec_min']  = hdu['SPEC_MIN'].data
        tslits_dict['spec_max'] = hdu['SPEC_MAX'].data
        # Kludge me
        tmp = hdu['MASK'].data
        tslits_dict['maskslits'] = tmp.astype(np.bool)
        #
        for ext in ['SLIT_LEFT_ORIG', 'SLIT_RIGH_ORIG']:
            if hdu[ext].data is not None:
                tslits_dict[ext.lower()] = hdu[ext].data

        return (tslits_dict, mstrace, hdu[0].header) if return_header else (tslits_dict, mstrace)


